<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>亦珍独立博客</title>
  
  <subtitle>爱生活，爱学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rizhenwei.github.io/"/>
  <updated>2019-03-24T08:19:58.976Z</updated>
  <id>https://rizhenwei.github.io/</id>
  
  <author>
    <name>Rizhen Wei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能测试-Jmeter工具基本使用</title>
    <link href="https://rizhenwei.github.io/2019/03/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Jmeter%E5%B7%A5%E5%85%B7%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://rizhenwei.github.io/2019/03/24/性能测试-Jmeter工具基本使用/</id>
    <published>2019-03-24T07:15:22.000Z</published>
    <updated>2019-03-24T08:19:58.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jmeter-工具基本使用方法"><a href="#Jmeter-工具基本使用方法" class="headerlink" title="Jmeter 工具基本使用方法"></a>Jmeter 工具基本使用方法</h1><h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>地址：<a href="http://jmeter.apache.org/" target="_blank" rel="noopener">Jemter 安装地址</a><br>怎么装的问度娘，多得很</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="添加HTTP接口"><a href="#添加HTTP接口" class="headerlink" title="添加HTTP接口"></a>添加HTTP接口</h2><ul><li>一般步骤：“测试计划”–&gt;“添加”–&gt;“Threads(Users)”–&gt;“线程组”<br>对应的</li></ul><p><a href="https://www.cnblogs.com/fnng/p/5827577.html" target="_blank" rel="noopener">Jmeter 基本用法</a></p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p><a href="https://www.cnblogs.com/fnng/archive/2012/12/29/2839420.html" target="_blank" rel="noopener">Jmeter 高级使用技巧-分布式测试&amp;线程间变量传递</a></p><h2 id="简单的性能测试"><a href="#简单的性能测试" class="headerlink" title="简单的性能测试"></a>简单的性能测试</h2><p><a href="https://www.cnblogs.com/fnng/archive/2012/12/22/2829479.html" target="_blank" rel="noopener">性能测试-sample-http请求</a></p><p><a href="https://www.cnblogs.com/fnng/archive/2011/08/03/2126775.html" target="_blank" rel="noopener">一种简单的数据库性能测试方法</a></p>]]></content>
    
    <summary type="html">
    
      介绍Jmeter基本使用方法
    
    </summary>
    
      <category term="Jemeter" scheme="https://rizhenwei.github.io/categories/Jemeter/"/>
    
      <category term="性能测试" scheme="https://rizhenwei.github.io/categories/Jemeter/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://rizhenwei.github.io/2019/03/17/hello-world/"/>
    <id>https://rizhenwei.github.io/2019/03/17/hello-world/</id>
    <published>2019-03-17T09:06:16.501Z</published>
    <updated>2018-12-28T13:48:00.570Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux-shell基础语法</title>
    <link href="https://rizhenwei.github.io/2019/03/17/Linux-shell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://rizhenwei.github.io/2019/03/17/Linux-shell基础语法/</id>
    <published>2019-03-17T07:26:22.000Z</published>
    <updated>2019-03-17T08:21:22.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><blockquote><p>环境变量： </p></blockquote><p>env 命令可以查看shell下的所有环境变量， 常用的环境变量有:</p><ul><li>HOME: 用户主文件夹</li><li>SHELL: shell使用的是哪一个程序</li><li>HISTSIZE: 是历史命令记录条数有关。 默认是1000</li><li>MAIL:用户取用的mailbox位置</li><li>PATA:执行文件查找的路径</li><li>INPUTRC:与按键功能有关， 可以设置特殊案件</li><li>LANG: 语系数据， 终端显示乱码的时候需要调试（不同语系造成）， 修改方法, 先查看支持多少种语系， 命令 locale –a查找后， 在执行locale 命令进行相应的修改</li></ul><blockquote><p>Linux Shell 通配符、 转义字符、 元字符、 特殊字符</p></blockquote><p><strong>通配符</strong><br><img src="/2019/03/17/Linux-shell基础语法/通配符.png" alt="通配符"><br><strong>转义符</strong><br><img src="/2019/03/17/Linux-shell基础语法/转义符.png" alt="转义符"><br><strong>转义符</strong><br><img src="/2019/03/17/Linux-shell基础语法/元字符.png" alt="元字符"></p><blockquote><p>常用的一些命令</p></blockquote><p><strong>打印和设值： </strong><br>变量显示 echo 要在变量前加上’’<br>变量设置： unset 或用“=”连接， 用“”或转译符“\”号保持特殊字符原特性；<br>如果要在其他子程序中使用， 要增加export 使得他变为环境变量；<br><strong>变量有效范围： </strong><br>局部变量=自定义变量；<br>全局变量=环境变量， 可以被子进程引用<br>read： 读取来自键盘的输入变量<br>declare： 申明变量类型  常用的有“整数数字”“字符串”-默认、 “只读类型”、 “环境变量”、 “数组”——读取方式 ${数组}<br><strong>变量删除、 替换</strong>： </p><ul><li>删除</li></ul><p>‘#’:从前边开始删除变量内容, 仅仅删除符合替换文字最短的那个<br>‘##’:从前边开始删除变量内容, 仅仅删除符合替换文字最短的那个<br>%:从后面向前删除<br>表达方式： echo ${path#/<em>xxx}  其中</em>xxx是被删除部分</p><ul><li>替换</li></ul><p><code>`auto默认值替换， 如果变量$var没有定义， 则整体值为default字符串， 但var变量本身并没有被设置${var-default}        // 如果var定义了， 但为空， 则还使用$var， 即为空auto`</code></p><p><code>`auto${var:-default}          //如果var定义了， 但为空， 则使用default字符串, 默认值设置， 包含默认值替换的所有功能（标准输出一样）， 不同在于， 如果变量$var没有定义， 则在输出default字符串的同时， $var也被设置成default字符串auto`</code><br> <code>${var=default}           //如果var定义了， 但为空， 则还使用$var， 即为空</code> </p><p> <code>${var:=default}           //如果var定义了， 但为空， 则将$var设置成default字符串</code> <strong><br>定向输入， 输出： </strong><br>    ‘&gt;&gt;’: 定向输出到指定文件 对标准错误定向输出， 要把准备定向文件的描述符编号放在 &gt; 操作符之前。 例如 kill– l 1234 &gt; /dev/null<br>2 &gt; &amp; l 放到回收站 “&lt;&lt;”: 定向标准输入 <strong><br>    管道： </strong><br>    linux 可以通过管道连接进程， 之间的数据流可以协调<br>ps– xo coom | sort | uniq | grep– v sh | more<br><code>`auto字符串、 环境变量、 参数变量： 字符串有空格要用引号括起来， 等号两边没有空格$HOME    //当前用户主目录$PATH    //用分隔号分开的用来收索的目录  $#        //传递给脚本参数的个数$1, $2..    //脚本程序的参数auto`</code></p><h2 id="二、数据流定向"><a href="#二、数据流定向" class="headerlink" title="二、数据流定向"></a>二、数据流定向</h2><blockquote><p>：以覆盖的方法将『正确的数据』输出到指定的文件或装置上<br>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上<br>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上<br>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上<br>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上<br>2&gt;&amp; 1：将正确和错误的数据全部写入到指定文件或装置上</p></blockquote><p>&lt;：将原本需要由键盘输入的数据，改由文件内容来取代<br>&lt;&lt;：代表的是『结束的输入字符』<br>&lt;&lt;&lt;:将字符串重定向到stdin。</p><p>例子：<br>find /home –name testing &gt;t1.txt 2&gt;t2.txt  将正确输出和错误输出存放在不同文件<br>find /home –name testing &gt;t1.txt 2&gt;&amp;1  将正确输出和错误输出存放在t1.txt同文件</p><p><strong>命令执行判断依据</strong><br>命令执行判断依据–;,&amp;&amp;,||<br>在Linux运维过程中或者日常Linux系统操作过程中会同时执行多条命令，这样的话需要通过我们的多重命令方式进行处理。<br>1.<br>通过使用’;’分号执行多个命令，如例：<br><code>#sync;sync;shutdown -h now</code><br>2.<br>通过判断执行命令，&amp;&amp;/||执行情况 如例:<br><strong><code>cmd1&amp;&amp;cmd2:</code></strong><br><em><code>若cmd1执行完毕且正确执行($?=0),则开始执行cmd2若cmd1执行完毕且错误执行($?!=0),则开cmd2不执行</code></em><br><strong><code>cmd1||cmd2:</code></strong><br><em><code>若cmd1执行完毕后正确执行($?=0),则cmd2不执行。若cmd1执行完毕后为错误($?!=0),则开始只执行cmd2</code></em></p><p><strong>管道：</strong><br>linux 可以通过管道连接进程，之间的数据流可以协调<br><code>ps –xo coom | sort |uniq | grep –v sh |more</code></p><ul><li><p>1）管道命令仅为处理标准输出（即正确的输出），对于标准错误输出，将忽略</p></li><li><p>2）管理命令的后一个命令必须能将前一个命令的标准输出变为它的标准输入才可以，如less,more,head,tail就可以，而ls, cp, mv就不行。</p></li></ul><p><strong>选取命令</strong><br>cut - 列选取命令<br>cut -d ‘分隔字符’ -f 选取的列数<br><code>echo $PATH|cut -d &#39;:&#39; -f 3,5</code>  –选取第3列和第5列<br>grep - 行选取命令<br>grep分一行数据，若当中有我们所需要的信息，则显示该行，否则忽略。<br>grep [-cinv] ‘查找的字符串’ filename<br>-c：计算找到的次数<br>-i：忽略大小写<br>-v：反向选择<br>-n：输出第几行</p><p><code>grep [-acivn] [--color=auto]</code> ’查找字符串‘ filename<br>-a: 将binary文件以test文件的方式查找数据；-c:计算找到’查找字符串’的次数；-i：忽略大小写的不同，所以大小写视为相同；-n：顺便输出行号；-v:反向选择，即显示出没有‘查找字符串’内容的一行；–color=auto:可以将找到的关键字部分加上颜色显示<br> <code>last | grep -v &#39;root&#39; | cut -d &#39; &#39; -f1</code><br> <code>grep --color=auto &#39;MANPATH&#39; /etc/man.config</code><br>排序命令：sort:依据不同的数据类型进行排序,wc：统计,uniq:重复的数据仅列出一个<br>sort: 使用LANG=C让语系统一，数据排序比较好一点<br><code>sort [-fbMnrtuk] [file or stdin]</code><br>参数：<br>-f : 忽略大小写；-b ：忽略最前面；-M ：以月份的名字来排序；-n ：使用“纯数字”进行排序；-r：反向排序；-u： 就是uniq,相同的数据中，仅出现一行代表；-t：分隔符，默认[tab]键来分隔； -k ：以那个区间（field）来进行排序的意思<br><code>cat /etc/passwd | sort ; cat /etc/passwd | sort -t &#39;:&#39; -k 3 ; last | cut -d &#39; &#39; -f1 | sort uniq [-ic]</code><br>参数：<br>-i：忽略大小写字符的不同； -c：进行计数<br><code>last | cut -d &#39; &#39; -f1 |sort|uniq -c</code><br><code>wc [-lwm]</code><br>参数：<br>-l ： 仅列出行；-w ：仅列出多少字（英文单字）；-m ：仅列出字符<br>last可以输出登陆者，但最后两行并非账号内容。取得月份登陆系统的总人数<br><code>last | grep [a-zA-Z]|grep -v wtmp|wc -l</code><br><code>last | tee last.list | cut -d &quot; &quot; -f1        ;   ls -l | tee -a ~/homefile |more</code>   (-a,将信息累加而不是覆盖）<br>字符转换命令： tr,col,join,paste,epand<br>tr:可以用来删除一段信息当中的文字，或者进行文字信息替换<br>tr [-ds] SET1 …<br>参数：<br>-d:删除信息当中的SET1Z这个字符串；-s：替换掉重复字符串<br><code>last | tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code><br><code>cat /etc/passwd | tr -d &#39;:&#39;</code>  将：删除<br><code>cp /etc/passwd /root/passwd &amp;&amp; UNIX2dos /root/passwd</code><br><code>file /etc/passwd /root/passwd</code><br><code>col [-xb]</code><br>参数：<br>-x:将tab键转换成对等的看空格键；-b ：在文字内有反斜杠（/）时，仅保留反斜杠最后接的那个字符<br>例如：cat -A 显示所有特殊按钮，最后以col将[tab]转为空白<br><code>cat -A /etc/man.conf</code>    &lt;==此时看到很多^I的符号，那就是tab<br><code>cat /etc/man.config | col -x | cat -A | more</code>      [tab]键会转为空格键<br>join  加入/参加   在处理两个文件之间的数据。将两个文件当中的相同数据那一行加在一起。<br><code>join [-ti12] file1 file2</code><br>参数：<br> -t : join默认以空格符分隔数据，并且对比“第一个字段”的数据；-i: 默认忽略大小写 ； -1 ：代表第一个文件要用哪个字段分析的意思 ； -2 ：代表第二个字段用哪个字段来分析<br>[root@master ssh]# join -t ‘:’ /etc/passwd /etc/shadow<br> paste [-d] file1 file2  直接将两行粘在一起，且中间以[tab]隔开<br> 参数：<br> -d : 后面可以接分隔符，默认以tab来分隔；- ： 如果file部分写成- ，表示来自shandard input 的数据的意思<br>[root@master ssh]# <code>paste /etc/passwd /etc/shadow</code><br><code>expand [-t] file</code>  将[tab]键转成空格<br><code>grep &quot;^MANPATH&quot; /etc/man.config |head -n 3 | expand -t 6 - | cat -A</code><br>切割命令 split    大文件切割成小文件<br><code>split [-bl] file PREFI</code></p><p>-b ：后面可接欲切割的文件大小，可加单位 例如：b,k,m等；    -l ：以行数来进行切割；<br><code>cd /tmp ; split -b 300k /etc/termcap termcap  ;  ll -k trmcap*</code><br>参数代换： xargs [-0epn] command<br>参数：<br>-0 ： 如果输入stdin含有特殊字符，例如<code>,/ 空格字符时，这个参数可以将它还原成一般符号； -e :EOF，后面接一个字符串，xargs分析到这个字符串时，就会停止工作； -p ： 在执行每个命令的参数时，都会询问用户的意思；-n ：后面接次数，诶次command命令都会执行。找出具有特殊权限的文件名</code>find /sbin -perm +7000 |ls -l`</p>]]></content>
    
    <summary type="html">
    
      基础等常规shell命令
    
    </summary>
    
      <category term="Linux" scheme="https://rizhenwei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rizhenwei.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://rizhenwei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux-文件权限和目录配置</title>
    <link href="https://rizhenwei.github.io/2019/03/17/Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>https://rizhenwei.github.io/2019/03/17/Linux-文件权限和目录配置/</id>
    <published>2019-03-17T07:25:15.000Z</published>
    <updated>2019-03-17T08:21:45.413Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文件属性</strong><br> 查看命令：ls -al<br>对应：【权限】【连接数】【所有者】【用户组】【文件容量】【修改日期】【文件名】<br>第一列：文件权限<br>一共长度为10个字符<br>第一个字符为：表示”目录、文件、链接“ 以【d】开头是目录；以【-】开头是文件；以【i】开头是链接；以【c】开头是串口端设备<br>以下的3个字符为一组；第一组是文件所有者的权限、第二组是相同用户组的权限、第三组是其他非相同用户组的权限；<br>每一组的权限由“rwx”组成，对应为没有的用“-”代替，其中“r”为可读、“w”为可写，“x”为可执行<br><strong>改变文件属性&amp;&amp;权限</strong><br>命令：<br><code>chgrp  [-R]  DIR/FIRNAME</code> ：          递归的改变文件所属于的用户组<br><code>chown   [-R]  账号名 文件or目录</code>：     递归的改变文件所有者<br><code>chomd   数字类型/符号类型</code>：           改变文件属性<br>数字类型  r:4  w:2  x:1  权限分配表<br>符号类型：<code>chmod  [u/g/o/a] [+/-/=] [r/w/x]</code><br>第一列表示用户组：拥有着、共同用户组、其他用户、全部用户  ； 第二列表示： 增加、去除、设置 ； 第三列表示权限 </p><p><strong>linux 文件种类和扩展名</strong><br>文件种类：普通文件、纯文本文件（ascii）、二进制文件、数据文件（data）、设备文件（device）、链接（link）、接口文件（sockets）<br>管道（fifo\pipe）<br>文件扩展名：没有扩展名和文件属性有关<br>但为方便与win相识</p><p><strong>目录树</strong><br><img src="/2019/03/17/Linux-文件权限和目录配置/文件目录树.png" alt="文件目录树"></p>]]></content>
    
    <summary type="html">
    
      linux文件权限汇总
    
    </summary>
    
      <category term="Linux" scheme="https://rizhenwei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rizhenwei.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://rizhenwei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux-正则表达式</title>
    <link href="https://rizhenwei.github.io/2019/03/17/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://rizhenwei.github.io/2019/03/17/Linux-正则表达式/</id>
    <published>2019-03-17T07:24:28.000Z</published>
    <updated>2019-03-17T08:22:24.850Z</updated>
    
    <summary type="html">
    
      常用正则表达式
    
    </summary>
    
      <category term="Linux" scheme="https://rizhenwei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rizhenwei.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://rizhenwei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>容器架构</title>
    <link href="https://rizhenwei.github.io/2019/03/17/%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <id>https://rizhenwei.github.io/2019/03/17/容器架构/</id>
    <published>2019-03-17T05:51:19.000Z</published>
    <updated>2019-03-17T07:12:59.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-什么是容器（What）"><a href="#一、-什么是容器（What）" class="headerlink" title="一、 什么是容器（What）"></a>一、 什么是容器（What）</h1><p>由两部分组成： 应用程序本身、 依赖</p><h1 id="二、为什么需要容器（Why）"><a href="#二、为什么需要容器（Why）" class="headerlink" title="二、为什么需要容器（Why）"></a>二、为什么需要容器（Why）</h1><p>容器具备了超强的可移植能力<br><strong>Docker 特性</strong></p><ul><li>打包对象：任何的软件及其依赖</li><li>硬件依赖：无需修改便可以运行几乎所有的平台</li><li>隔离性：提供run、start、stop标准操作</li><li>高效性：轻量级、快速启动迁移</li><li>职能分工：开发-运维</li></ul><p><strong>容器优势</strong></p><ul><li>环境隔离、可重复性</li></ul><h1 id="三、容器是如何工作（How）"><a href="#三、容器是如何工作（How）" class="headerlink" title="三、容器是如何工作（How）"></a>三、容器是如何工作（How）</h1><h1 id="四、Docker架构详解"><a href="#四、Docker架构详解" class="headerlink" title="四、Docker架构详解"></a>四、Docker架构详解</h1><p><strong>Docker 的核心组件</strong></p><ul><li>Docker 客户端-Client，最常用的客户端是docker命令，支持很多子命令</li><li>Docker 服务端-Docker daemon，运行在docker host上，负责创建、运行、监控容器，构建、存储镜像</li><li>Docker 镜像-Image，可以将镜像看作只读模板，通过他可以创建Docker容器，创建的方法有：从无到有、下载已有的现成镜像；<br><em>将镜像的内容和创建步骤描述在一个文件钟，这个文件被称作Dockerfile,通过执行docker build <docker-file> 可以创建出Docker的镜像</docker-file></em></li><li>Registry-存放Docker镜像的仓库，分为公有和私有，其中 docker pull（下载镜像）、docker run（先下载镜像咋启动容器）</li><li>Docker 容器-Container，就是docker镜像运行的实例，用户可以通过CLI 或者API启动、停止、移动或者删除容器。</li></ul><h1 id="组件如何协作"><a href="#组件如何协作" class="headerlink" title="组件如何协作"></a>组件如何协作</h1><p><strong>容器启动流程</strong></p><ul><li>1、Docker 客户端执行 docker run 命令</li><li>2、Docker daemon 发现本地没有对应的镜像</li><li>3、daemon 从Docker hub 下载镜像</li><li>4、下载完成后，镜像被保存到本地</li><li>Docker daemon 启动容器去<br><strong>相关命令</strong></li></ul><ul><li>docker images:查看本地的镜像</li><li>docker ps：显示正在运行的容器</li><li>docker run:启动容器</li></ul>]]></content>
    
    <summary type="html">
    
      容器What Why How
    
    </summary>
    
      <category term="Docker容器技术" scheme="https://rizhenwei.github.io/categories/Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="容器" scheme="https://rizhenwei.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>容器生态系统</title>
    <link href="https://rizhenwei.github.io/2019/03/17/%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"/>
    <id>https://rizhenwei.github.io/2019/03/17/容器生态系统/</id>
    <published>2019-03-17T04:25:28.000Z</published>
    <updated>2019-03-17T07:13:13.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器生态系统"><a href="#容器生态系统" class="headerlink" title="容器生态系统"></a>容器生态系统</h1><p>介绍容器生态系统包含哪些技术、 技术之间的相互关系、 核心的技术等  </p><p><img src="/2019/03/17/容器生态系统/容器生态系统.png" alt="容器生态图"></p>]]></content>
    
    <summary type="html">
    
      整体介绍容器的生态系统
    
    </summary>
    
      <category term="Docker容器技术" scheme="https://rizhenwei.github.io/categories/Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="容器" scheme="https://rizhenwei.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客搭建-系统安装和配置</title>
    <link href="https://rizhenwei.github.io/2018/12/28/hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://rizhenwei.github.io/2018/12/28/hexo-博客搭建-系统安装和配置/</id>
    <published>2018-12-28T15:44:56.000Z</published>
    <updated>2018-12-28T15:44:57.305Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
